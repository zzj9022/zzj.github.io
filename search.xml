<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2020/06/09/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">"My New Post"</span><br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>发现fastjson有意思的事</title>
    <url>/2020/06/11/%E5%8F%91%E7%8E%B0fastjson%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E4%BA%8B/</url>
    <content><![CDATA[<h3 id="fastjson"><a href="#fastjson" class="headerlink" title="fastjson"></a>fastjson</h3><blockquote>
<p>本想着测试一下，直接用fastjson输出json时直接将null值转为空串，然后发现这事…</p>
</blockquote>
<p>使用的maven依赖版本：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fastjson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.68<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>测试代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;String, Object&gt;();<br>map.put(<span class="hljs-string">"age"</span>, <span class="hljs-number">18</span>);<br>map.put(<span class="hljs-string">"name"</span>, <span class="hljs-keyword">null</span>);<br><span class="hljs-comment">//默认输出</span><br>String s = JSON.toJSONString(map);<br>System.out.println(<span class="hljs-string">"map默认输出值："</span> + s);<br><br>User user = <span class="hljs-keyword">new</span> User();<br>user.setAge(<span class="hljs-number">18</span>);<br>user.setName(<span class="hljs-keyword">null</span>);<br>String s3 = JSON.toJSONString(user);<br>System.out.println(<span class="hljs-string">"user默认:"</span> + s3);<br></code></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs json">map默认输出值：&#123;"age":18&#125;<br>user默认:&#123;"age":18&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>从输出结果可以看出，默认输出时null对应的key已经被过滤掉，这时我们用到了fastjson的<strong>SerializerFeature</strong>序列化属性.</p>
</blockquote>
<p>SerializerFeature中有用的一些枚举值如下（加粗为常用的）：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th align="left">含义</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><strong>QuoteFieldNames</strong></td>
<td align="left"><strong>输出key时是否使用双引号</strong></td>
<td><strong>默认为true</strong></td>
</tr>
<tr>
<td>UseSingleQuotes</td>
<td align="left">使用单引号而不是双引号</td>
<td>默认为false</td>
</tr>
<tr>
<td>WriteNullBooleanAsFalse</td>
<td align="left">Boolean字段如果为null,输出为false,而非null</td>
<td></td>
</tr>
<tr>
<td>WriteNullNumberAsZero</td>
<td align="left">数值字段如果为null,输出为0,而非null</td>
<td></td>
</tr>
<tr>
<td>WriteNullListAsEmpty</td>
<td align="left">List字段如果为null,输出为[],而非null</td>
<td></td>
</tr>
<tr>
<td><strong>WriteNullStringAsEmpty</strong></td>
<td align="left"><strong>字符类型字段如果为null,输出为”“,而非null</strong></td>
<td></td>
</tr>
<tr>
<td>WriteDateUseDateFormat</td>
<td align="left">全局修改日期格式</td>
<td>默认为false</td>
</tr>
<tr>
<td><strong>WriteMapNullValue</strong></td>
<td align="left"><strong>是否输出值为null的字段</strong></td>
<td><strong>默认为false</strong></td>
</tr>
<tr>
<td>WriteEnumUsingToString</td>
<td align="left">Enum输出name()或者original</td>
<td>默认为false</td>
</tr>
<tr>
<td>SkipTransientField</td>
<td align="left">如果是true，类中的Get方法对应的Field是transient，序列化时将会被忽略</td>
<td>默认为true</td>
</tr>
<tr>
<td>SortField</td>
<td align="left">按字段名称排序后输出</td>
<td>默认为false</td>
</tr>
<tr>
<td>WriteTabAsSpecial</td>
<td align="left">把\t做转义输出，</td>
<td>默认为false 不推荐</td>
</tr>
<tr>
<td>PrettyFormat</td>
<td align="left">结果是否格式化</td>
<td>默认为false</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">String s1 = JSON.toJSONString(map, SerializerFeature.WriteMapNullValue, SerializerFeature.WriteNullStringAsEmpty);<br>System.out.println(<span class="hljs-string">"map转为空串--&gt;不起作用："</span> + s1);<br><br>String s4 = JSON.toJSONString(user, SerializerFeature.WriteMapNullValue, SerializerFeature.WriteNullStringAsEmpty);<br>System.out.println(<span class="hljs-string">"user转为空串"</span> + s4);<br></code></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs json">map转为空串--&gt;不起作用：&#123;"name":null,"age":18&#125;<br>user转为空串&#123;"age":18,"name":""&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>这时候我们发现，map和user对象同样使用SerializerFeature后：user对象输出就是我们要的结果，而map虽然输出了name的值为nulll,说明<strong>WriteMapNullValue</strong>是有作用的，但是<strong>WriteNullStringAsEmpty</strong>转换竟然<strong>不起作用</strong>！！！</p>
</blockquote>
<p>一阵噼里啪啦网上查找时，我们发现可以造一个fastjson的过滤器，是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ValueFilter filter = <span class="hljs-keyword">new</span> ValueFilter() &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">process</span><span class="hljs-params">(Object obj, String s, Object v)</span> </span>&#123;<br>    	<span class="hljs-keyword">if</span> (v == <span class="hljs-keyword">null</span>) &#123;<br>    		<span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;<br>    	&#125;<br>    	<span class="hljs-keyword">return</span> v;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>然后转换时直接使用filter，这样就可以了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">String s2 = JSON.toJSONString(map, MainTest.filter);<br>System.out.println(<span class="hljs-string">"map使用filter:"</span> + s2);<br></code></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs json">map使用filter:&#123;"name":"","age":18&#125;<br></code></pre></td></tr></table></figure>

<p>其实我们用SerializerFeature主要是针对Object对象序列化转换时的情况（这个时候能判断参数的类型），而在Map中，放进入了null就是null，进行序列化时已经没法判断它原来的类型了，所以并没有起作用！~</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>mySql查出用户常用手机号码</title>
    <url>/2020/06/09/mySql%E6%9F%A5%E5%87%BA%E7%94%A8%E6%88%B7%E5%B8%B8%E7%94%A8%E6%89%8B%E6%9C%BA%E5%8F%B7%E7%A0%81/</url>
    <content><![CDATA[<h4 id="mySql查出用户常用手机号码"><a href="#mySql查出用户常用手机号码" class="headerlink" title="mySql查出用户常用手机号码"></a>mySql查出用户常用手机号码</h4><blockquote>
<p>由于设计问题，自己手机号可有多个，联系人的手机号又有多个，现设计为在这一堆手机号中必勾选一个为常用电话，现需查出用户唯一的常用手机号做批量处理。</p>
</blockquote>
<p>在自己一堆手机号中使用了<u>recently字段为1</u>作为常用手机号，而在联系人一堆手机号中使用了<u>is_default字段为1</u>作为常用手机号，而两张表中的手机号字段也不同，故使用了case when语句进行输出处理。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT pb.id,pb.&#96;name&#96;,pb.nationality,<br>CASE	<br>	WHEN pp.recently &#x3D; 1 THEN<br>	pp.patient_tel <br>	WHEN pc.is_default &#x3D; 1 THEN<br>	pc.contacts_tel <br>	END tel <br>FROM<br>	patient_basic_info pb<br>	LEFT JOIN patient_phone pp ON pb.id &#x3D; pp.patient_id <br>	AND pp.is_del &#x3D; 1 <br>	AND pp.recently &#x3D; 1<br>	LEFT JOIN patient_contacts pc ON pb.id &#x3D; pc.patient_id <br>	AND pc.is_del &#x3D; 1 <br>	AND pc.is_default &#x3D; 1 <br>	where pb.id &#x3D; 876025<br></code></pre></td></tr></table></figure>

<p>当前Sql可查出某个用户ID的常用手机号，如全部查出需将最后where语句删除即可。</p>
<blockquote>
<p>MySql 中关键字 case when then else end 的用法</p>
</blockquote>
<p>数据SQL CASE 表达式是一种通用的条件表达式，类似于其它语言中的 <strong>if/else</strong> 语句。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">CASE WHEN condition THEN result <br>　　　WHEN condition THEN result <br>　　　.............<br>　　　[WHEN ...] <br>　　　[ELSE result] <br>END<br></code></pre></td></tr></table></figure>

<p>​        CASE 子句可以用于任何表达式可以有效存在的地方。 condition 是一个返回boolean 的表达式。 如果结果为真，那么 CASE 表达式的结果就是符合条件的 result。 如果结果为假，那么以相同方式搜寻任何随后的 WHEN 子句。 如果没有 WHEN condition 为真，那么 case 表达式的结果就是在 ELSE 子句里的值。 如果省略了 ELSE 子句而且没有匹配的条件, 结果为 NULL。</p>
<p>eg.简单举例，如果将数据库里1、2换为男女，则可以直接输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">select name,<br>    case <br>    when sex&#x3D;&#39;1&#39; then &#39;男&#39;<br>    when sex&#x3D;&#39;2&#39; then &#39;女&#39; <br>    else &#39;无性别&#39; <br>    end sex<br>    from user_table;<br></code></pre></td></tr></table></figure>
<p>当然，我们在实际应用中，通常不会这样直接查库后用sql转换数据值，可通过后端实体输出时或者前端直接做判断修改等方式进行即可。</p>
]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>实战派(第5章)</title>
    <url>/2020/07/24/%E5%AE%9E%E6%88%98%E6%B4%BE-5/</url>
    <content><![CDATA[<h1 id="第5章-Spring-Cloud基础"><a href="#第5章-Spring-Cloud基础" class="headerlink" title="第5章 Spring Cloud基础"></a>第5章 Spring Cloud基础</h1><h3 id="了解Spring-Cloud生态"><a href="#了解Spring-Cloud生态" class="headerlink" title="了解Spring Cloud生态"></a>了解Spring Cloud生态</h3><ul>
<li><h4 id="主要子项目"><a href="#主要子项目" class="headerlink" title="主要子项目"></a>主要子项目</h4></li>
</ul>
<ol>
<li><p>Spring Cloud Config</p>
<p>配置管理工具，通过它可以把配置信息放到远程服务器中，从而集中管理集群配置。</p>
</li>
<li><p>Spring Cloud Consul</p>
<p>封装了Consul，Consul是Go语言开发的服务治理软件，它包含服务质量、健康检查、Key-value存储、多数据中心功能。</p>
</li>
<li><p>Spring Cloud Sleuth</p>
<p>为Spring Cloud应用提供了分布式最终解决方案，微服务之间的调用提供了链路追踪。</p>
</li>
<li><p>Spring Cloud Starters</p>
<p>是Spring Boot式的项目，为Spring Cloud提供了“开箱即用”的依赖管理</p>
</li>
<li><p>Spring Cloud Gateway</p>
<p>提供了一种简单有效的方式来对微服务的API进行路由</p>
</li>
<li><p>Spring Cloud OpenFeign</p>
<p>封装了声明式的Web Service客户端Feign，它使得编写Web Service客户端变得更为容易。支持Feign注解和JAX-RS注解。</p>
<p>Spring Cloud支持Feign在Spring MVC中使用，并整合了Ribbon和Eureka以便在使用Feign时提供负载均衡。</p>
</li>
<li><p>Turbine</p>
<p>聚合服务器。用来发送事件流数据，以监控集群中Hystrix的Metrics情况。</p>
</li>
</ol>
<ul>
<li><h4 id="Netflix家族项目"><a href="#Netflix家族项目" class="headerlink" title="Netflix家族项目"></a>Netflix家族项目</h4></li>
</ul>
<ol>
<li><p>Eureka</p>
<p>服务治理组件，它基于Rest的服务，包含服务注册于服务发现功能。</p>
</li>
<li><p>Hystrix</p>
<p>SpringCloud可以整合Hystrix来对微服务进行容错管理。</p>
</li>
<li><p>Zuul</p>
<p>主要提供路由和过滤功能。它是各种服务的统一入口，还可以提供动态路由、监控、授权、安全、调度等功能。</p>
</li>
<li><p>Archaius</p>
<p>Spring Cloud整合Archaius（配置管理工具）来配置管理API。Archaius提供了动态类型化属性、线程安全配置操作、轮训框架、回调机制等功能。</p>
<blockquote>
<p>动态获取配置，默认60s从配置源读取一次内容，不需要重启也可使修改后的内容生效。</p>
</blockquote>
</li>
</ol>
<ul>
<li><h4 id="阿里巴巴家族项目"><a href="#阿里巴巴家族项目" class="headerlink" title="阿里巴巴家族项目"></a>阿里巴巴家族项目</h4></li>
</ul>
<ol>
<li><p>Sentinel</p>
<p>流控组件，以流量作为切入点，可以从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。</p>
</li>
<li><p>Nacos</p>
<p>和Eureka、Consul一样也是一个服务治理的项目，它提供了动态服务发现、配置管理和服务管理平台。</p>
</li>
<li><p>RocketMQ</p>
<p>和RabbitMQ类似的一种消息中间件，它基于高可用分布式集群技术提供低延时、高可靠的消息发布/订阅服务。</p>
</li>
<li><p>Dubbo</p>
<p>高性能Java RPC（Romote Procedure Call，远程过程调用）框架。</p>
</li>
<li><p>Seata</p>
<p>高性能的微服务分布式事务解决方案。</p>
</li>
<li><p>Alibaba Cloud ACM</p>
<p>应用配置中心，用于在分布式架构环境中对应用配置进行集中管理和推送。</p>
</li>
<li><p>Alibaba Cloud SchedulerX</p>
<p>基于Cron表达式的任务调度服务，可提供秒级、精准、高可靠、高可用的定时任务调度功能。</p>
</li>
</ol>
<ul>
<li><h4 id="常用的技术栈"><a href="#常用的技术栈" class="headerlink" title="常用的技术栈"></a>常用的技术栈</h4><ul>
<li>服务开发：Spring Boot、Spring MVC、Spring。</li>
<li>服务的注册与发现：Eureka、Consul、Zookeeper。</li>
<li>服务的配置与管理：Spring Cloud Config、Archaius、Diamound、Apollo、Nacos等。</li>
<li>服务的调用方式：Rest、GRPC、RPC。</li>
<li>服务的熔断器：Hystrix、Envoy等。</li>
<li>负载均衡：Ribbon、Nginx、F5。</li>
<li>服务接口调用：Feign、Kafka、RabbitMQ等。</li>
<li>服务监控：Spring Boot Admin、Zabbix、Nagios、Metrics、Spectator等。</li>
<li>全链路追踪：Zipkin、Brave、Dapper等</li>
<li>服务部署：Docker、Open Stack、Kubernetes等。</li>
<li>数据流操作开发包：Spring Cloud Stream（封装Rabbit、Kafka等来发送接收消息）</li>
<li>事件消息总线：Spring Cloud Bus。</li>
<li>安全管理：Spring Cloud Security、Shiro。</li>
</ul>
</li>
</ul>
<h3 id="了解Spring-Cloud"><a href="#了解Spring-Cloud" class="headerlink" title="了解Spring Cloud"></a>了解Spring Cloud</h3><h4 id="Spring-Cloud-与Spring、Spring-Boot的关系"><a href="#Spring-Cloud-与Spring、Spring-Boot的关系" class="headerlink" title="Spring Cloud 与Spring、Spring Boot的关系"></a>Spring Cloud 与Spring、Spring Boot的关系</h4><ol>
<li><p>Spring</p>
<p>Spring为开发Java应用提供了全面的基础支持。它提供了依赖注入和开箱即用的一些模块，例如：Spring MVC、Spring JDBC、Spring Security、Spring AOP、Spring ORM、Spring Test等</p>
</li>
<li><p>Spring Boot</p>
<p>Spring Boot是Spring框架的扩展和自动化，它消除了在Spring中需要进行的XML配置，使得开发系统变得更快、跟高效、更自动化</p>
<p>1）使用简单。支持注解方式轻松实现类的定义和功能开发</p>
<p>2）配置简单。利用在类路径中的JAR和类自动配置Bean自动完成大量配置。另外它还支持通过自定义方式来配置项目。</p>
<p>3）提供大量的Starter来简化依赖配置。</p>
<p>4）部署简单。内置嵌入式Servlet容器，不用打包WAR格式，直接JAR包方式运行</p>
<p>5）与云计算天然集成。云应用框架Spring Cloud也是基于Spring Boot实现的。</p>
<p>6）监控简单。提供了一套对应用状态进行监控与管理的功能模块。</p>
</li>
<li><p>Spring Cloud</p>
<p>Spring Cloud是一个微服务开发和治理框架，它本身不提供具体功能性的操作，只专注与服务之间的通信、熔断和监控等。</p>
<p>微服务是可以独立部署、水平扩展、独立访问的服务单元。</p>
<p>Spring Cloud的特点：</p>
<ul>
<li>约定优于配置。</li>
<li>开箱即用、快速开发和启动</li>
<li>适用于各种环境</li>
<li>轻量级的组件。</li>
<li>组件支持丰富、功能齐全。</li>
</ul>
</li>
<li><p>Spring、Spring Boot、Spring Cloud的关系</p>
<ul>
<li>Spring Boot并不是一个全新的框架，它是Spring的自动化。</li>
<li>Spring Cloud基于Spring Boot来构建微服务应用。</li>
<li>Spring Cloud依赖于Spring Boot，Spring Boot依赖于Spring</li>
</ul>
</li>
</ol>
<h4 id="Spring-Cloud版本"><a href="#Spring-Cloud版本" class="headerlink" title="Spring Cloud版本"></a>Spring Cloud版本</h4><p>Spring Cloud版本的名字是根据伦敦的地铁站的站名而来的，命名方式为“版本+.SRX后缀”，其中“X”代表该版本的第几个Releases版本。</p>
<p>由于Spring Cloud是以Spring Boot为基础构建的，所以，在构建Spring Cloud项目时要考虑两者的适配情况。</p>
<table>
<thead>
<tr>
<th>Spring Cloud</th>
<th>Spring Boot</th>
</tr>
</thead>
<tbody><tr>
<td>Hoxton</td>
<td>2.2.x</td>
</tr>
<tr>
<td>Greenwich</td>
<td>2.1.x</td>
</tr>
<tr>
<td>Finchley</td>
<td>2.0.x</td>
</tr>
<tr>
<td>Edgware</td>
<td>1.5.x</td>
</tr>
<tr>
<td>Dalston</td>
<td>1.5.x</td>
</tr>
</tbody></table>
<h4 id="Spring-Cloud-项目的结构"><a href="#Spring-Cloud-项目的结构" class="headerlink" title="Spring Cloud 项目的结构"></a>Spring Cloud 项目的结构</h4><p>Spring Cloud是基于Spring Boot的，所以它们的项目结构是一样的。</p>
<p>Spring Cloud的基础结构分为3个文件目录：</p>
<ol>
<li>src/main/java：入口(启动)类及程序的开发目录。在这个目录下进行业务开发、创建实体层、控制器层、数据连接层等。</li>
<li>src/main/resources：资源文件目录，用于放置静态文件和配置文件<ul>
<li>static：用于放置静态资源，如CSS、JavaScript、图片文件等。</li>
<li>templates：用于存放模板文件。</li>
<li>application.properties：用于配置项目运行所需的配置数据。如果用YML方式管理配置，则YML文件也放在这个目录中，名为application.yml。</li>
</ul>
</li>
<li>src/test/java：测试程序所在的目录</li>
</ol>
<h4 id="Spring-Cloud的入口类"><a href="#Spring-Cloud的入口类" class="headerlink" title="Spring Cloud的入口类"></a>Spring Cloud的入口类</h4><p>创建项目时，自动创建用于启动的、名为“项目名+Application”的入口类，它是项目的启动入口。默认会加上注解@SpringBootApplication,以标识这是Spring Boot项目</p>
<h4 id="Spring-Cloud的自动配置"><a href="#Spring-Cloud的自动配置" class="headerlink" title="Spring Cloud的自动配置"></a>Spring Cloud的自动配置</h4><p>Spring Cloud自动配置是通过注解@EnableAutoConfiguration来实现的(Spring Boot也一样)，具有非入侵性。</p>
<p>如果不需要某些自动配置，则通过注解@EnableAutoConfiguration的“exclude”或“excludeName”属性来指定，或在配置文件(application.properties或application.yml)中指定“spring.autoconfigure.exclude”的值。</p>
<h4 id="开箱即用"><a href="#开箱即用" class="headerlink" title="开箱即用"></a>开箱即用</h4><p>Spring Cloud采用了一种特别的声明性方法，通常只需要改类路径或注释即可获得很多特性。</p>
<p>如加入注解“@EnableDiscoveryClient”即可启用服务发现客户端功能。</p>
<h3 id="了解注解"><a href="#了解注解" class="headerlink" title="了解注解"></a>了解注解</h3><h4 id="什么是注解"><a href="#什么是注解" class="headerlink" title="什么是注解"></a>什么是注解</h4><p>注解(Annotations)用来定义一个类、属性或一些方法，以便程序能被编译处理。</p>
<p>注解可以用于标注包、类、方法和变量等。</p>
<p>如：@RestController用来定义一个Rest风格的控制器。</p>
<h4 id="Spring-Boot的系统注解"><a href="#Spring-Boot的系统注解" class="headerlink" title="Spring Boot的系统注解"></a>Spring Boot的系统注解</h4><table>
<thead>
<tr>
<th align="left">注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">@Override</td>
<td>用于修饰方法，标识此方法重写了父类方法</td>
</tr>
<tr>
<td align="left">@Deprecated</td>
<td>用于修饰方法，表示此方法已经过时</td>
</tr>
<tr>
<td align="left">@SuppressWarnnings</td>
<td>告诉编译器忽视某类编译警告(属性较多，使用时再说)</td>
</tr>
</tbody></table>
<h4 id="Spring-Boot的常用注解"><a href="#Spring-Boot的常用注解" class="headerlink" title="Spring Boot的常用注解"></a>Spring Boot的常用注解</h4><ol>
<li>使用在类名上的注解</li>
</ol>
<table>
<thead>
<tr>
<th align="left">注解</th>
<th>使用位置</th>
<th align="left">说明</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td align="left">@RestController</td>
<td>类名上</td>
<td align="left">起作用相当于@ResponseBody和@Controller</td>
<td>用于返回Json、Xml等数据，但不能返回Html页面</td>
</tr>
<tr>
<td align="left">@Controller</td>
<td>类名上</td>
<td align="left">声明此类是一个SpringMVC Controller对象</td>
<td>用于标注控制器层，再MVC程序设计思想中代表C。</td>
</tr>
<tr>
<td align="left">@Service</td>
<td>类名上</td>
<td align="left">声明一个业务处理类(实现非接口类)</td>
<td>用于标注服务层、处理业务逻辑。</td>
</tr>
<tr>
<td align="left">@Repository</td>
<td>类名上</td>
<td align="left">声明数据库访问类(实现类、非接口类)</td>
<td>标注数据访问层</td>
</tr>
<tr>
<td align="left">@Component</td>
<td>类名上</td>
<td align="left">代表是Spring的管理类，常用在无法用@Service、@Reponsitory描述的Spring管理的类上，相当于通用的注解</td>
<td>用于把普通POJO实例化到Spring容器中。</td>
</tr>
<tr>
<td align="left">@Configuration</td>
<td>类名上</td>
<td align="left">声明此类是一个配置类，常与@Bean配合使用</td>
<td>标注配置类，并且可以由Spring容器自动处理。它作为Bean的载体，用来指示一个类声明一个或多个@Bean方法，在运行时为这些Bean生成BeanDefinition和服务请求。</td>
</tr>
<tr>
<td align="left">@Resource</td>
<td>类名上、属性或构造函数参数上</td>
<td align="left">默认按byName自动注入</td>
<td>装配Bean，也可以写在字段上或setter方法上</td>
</tr>
<tr>
<td align="left">@Autowired</td>
<td>类名上、属性或构造函数参数上</td>
<td align="left">默认按byType自动注入</td>
<td>表示被修饰的类需要注入对象。Spring会扫描所有被@Autowired标注的类，然后根据类型在IOC容器中找到匹配的类进行注入。</td>
</tr>
<tr>
<td align="left">@RequestMapping</td>
<td>类名或方法上</td>
<td align="left">如果用在类上，则表示所有用在方法上的相应请求都以该地址作为父类</td>
<td>用来处理请求地址映射，用在类或方法上</td>
</tr>
<tr>
<td align="left">@Transactional</td>
<td>类名或方法上</td>
<td align="left">用于处理事务</td>
<td>如果异常被捕获了，<strong>则事务就不回滚</strong>。如果想让事务回滚，则必须再往外抛出异常。</td>
</tr>
<tr>
<td align="left">@Qualifier</td>
<td>类名或属性上</td>
<td align="left">为Bean指定名称，随后再通过名字引用Bean</td>
<td>用于标注哪一个实现类才是需要注入的。<strong>参数名称为被注入的类中注解@Service标注的名称。</strong></td>
</tr>
</tbody></table>
<p>@RequestMapping：该注解有6个属性。</p>
<ul>
<li>Params：指定Request中必须包含某些参数值，这样才让该方法处理</li>
<li>Headers：指定Request中必须包含某些指定的Header值，这样才能让该方法处理请求。</li>
<li>Value：指定请求的实际地址，指定的地址可以是URI Template模式</li>
<li>Method：指定请求的Method类型，如Get、Post等</li>
<li>Consumes：指定处理请求的提交内容类型Content-Type，如“application/json,text/html”。</li>
<li>Produces：指定返回的内容类型。只有当Request请求头中Accept类型中包含该指定类型时才返回。</li>
</ul>
<ol start="2">
<li>使用在方法上的注解</li>
</ol>
<table>
<thead>
<tr>
<th>注解</th>
<th>使用位置</th>
<th>说明</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>@RequestBody</td>
<td>方法参数前</td>
<td>处理Content-Type类型的数据，将其转换为指定类型参数</td>
<td>常用来处理(JSON/XML)格式的数据。</td>
</tr>
<tr>
<td>@PathVariable</td>
<td>方法参数前</td>
<td>将URL获取的参数映射到方法参数上</td>
<td>用于获取路径中的参数</td>
</tr>
<tr>
<td>@Bean</td>
<td>方法上</td>
<td>声明该方法的返回结果是一个由Spring容器管理的Bean</td>
<td>它代表产生一个Bean，并交给Spring管理。</td>
</tr>
<tr>
<td>@ResponseBody</td>
<td>方法上</td>
<td>将方法返回的对象转换为指定格式后写入Responese对象的body数据区</td>
<td>通过转换器将控制器中的方法返回的对象转换指定的格式。常用来返回json、xml数据</td>
</tr>
</tbody></table>
<ol start="3">
<li>其他注解</li>
</ol>
<table>
<thead>
<tr>
<th>注解</th>
<th>使用位置</th>
<th>作用说明</th>
</tr>
</thead>
<tbody><tr>
<td>@EnableAutoConfiguration</td>
<td>入口类/类名上</td>
<td>用来提供自动配置</td>
</tr>
<tr>
<td>@SpringBootApplication</td>
<td>入口类/类名上</td>
<td>用来启动入口类Application</td>
</tr>
<tr>
<td>@EncableScheduling</td>
<td>入口类/类名上</td>
<td>用来开启计划任务。</td>
</tr>
<tr>
<td>@EnableAsync</td>
<td>入口类/类名上</td>
<td>用来开启异步注解功能</td>
</tr>
<tr>
<td>@ComponentScan</td>
<td>入口类/类名上</td>
<td>用来扫描组件，可以自动发现和装配一些Bean。</td>
</tr>
<tr>
<td>@Aspec</td>
<td>入口类/类名上</td>
<td>标注切面，可以用来配置事务、日志、权限验证，在用户请求时做一个处理</td>
</tr>
<tr>
<td>@ControllerAdvice</td>
<td>类名上</td>
<td>包含@Component,可以被扫描到。统一处理异常。</td>
</tr>
<tr>
<td>@ExceptionHandler</td>
<td>方法上</td>
<td>用在方法上面标识遇到这个异常就执行该方法</td>
</tr>
<tr>
<td>@Value</td>
<td>属性上</td>
<td>用于获取配置文件中的值。</td>
</tr>
</tbody></table>
<h4 id="Spring-Cloud的常用注解"><a href="#Spring-Cloud的常用注解" class="headerlink" title="Spring Cloud的常用注解"></a>Spring Cloud的常用注解</h4><table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@SpringCloudApplication</td>
<td>应用开启入口，比@SpringBootApplication更强大</td>
</tr>
<tr>
<td>@LoadBalanced</td>
<td>方便我们对RestTemplate添加一个LoadBalancerClient，以通过Ribbon实现客户端的负载均衡功能</td>
</tr>
<tr>
<td>@EnableEurekaClient</td>
<td>注解基于Spring Cloud Netflix，如果注册中心是Eureka，则推荐使用这个注解</td>
</tr>
<tr>
<td>@EnableEurekaServer</td>
<td>开启Eureka服务器端</td>
</tr>
<tr>
<td>@EnableDiscoveryClient</td>
<td>基于“spring-cloud-commons”，可以开启Eureka、Consul、Zookeeper客户端。</td>
</tr>
<tr>
<td>@EnableHystrix</td>
<td>标识q懂断路器，开启容错保护，断路器依赖服务注册和发现</td>
</tr>
<tr>
<td>@HystrixCommand</td>
<td>注解方法失败后，系统将奇幻岛fallabckMethod方法执行相应，如@HystrixCommand(fallbackMethod=”login”)，容错保护。</td>
</tr>
<tr>
<td>@FeignClient</td>
<td>用于发现服务，在注解中“fallbank”属性指定回调类</td>
</tr>
<tr>
<td>@EnableFeignClients</td>
<td>开启负载均衡客户端Feign的支持</td>
</tr>
<tr>
<td>@EnableZuulProxy</td>
<td>开启网关代理</td>
</tr>
</tbody></table>
<h3 id="了解Starter"><a href="#了解Starter" class="headerlink" title="了解Starter"></a>了解Starter</h3><h4 id="Spring-Boot的Starter"><a href="#Spring-Boot的Starter" class="headerlink" title="Spring Boot的Starter"></a>Spring Boot的Starter</h4><p>Spring Boot提供了非常多的Starter.即把常用的模块相关的所有jar包打包好，同时完成自动配置，然后组装成Starter。开发时不需要过多关注框架的配置，只需关注业务逻辑即可。</p>
<table>
<thead>
<tr>
<th>Starter</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>spring-boot-starter-web</td>
<td>用于构建Web，包含RESTful风格框架、<br />SpringMVC和默认的嵌入式容器Tomcat。</td>
</tr>
<tr>
<td>spring-boot-starter-mail</td>
<td>支持用Java Mail、Spring email发送邮件</td>
</tr>
<tr>
<td>spring-boot-starter-data-redis</td>
<td>通过Spring Data Redis、Redis client使用Redis</td>
</tr>
</tbody></table>
<h4 id="Spring-Cloud的Starter"><a href="#Spring-Cloud的Starter" class="headerlink" title="Spring Cloud的Starter"></a>Spring Cloud的Starter</h4><table>
<thead>
<tr>
<th>Starter</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>spring-cloud-satrter</td>
<td>Spring Boot式ID启动项目，<br />Spring Cloud提供开箱即用的依赖管理。</td>
</tr>
<tr>
<td>spring-cloud-start-netflix-eureka-server</td>
<td>“服务中心”Eureka服务器端的Starter依赖</td>
</tr>
<tr>
<td>spring-cloud-starter-netflix-eureka-client</td>
<td>“服务中心”Eureka客户端的Starter依赖</td>
</tr>
</tbody></table>
<h4 id="如何使用Starter"><a href="#如何使用Starter" class="headerlink" title="如何使用Starter"></a>如何使用Starter</h4><p>Starter本身就是依赖，只需要在pom.xml中添加依赖即可。</p>
<p>在pom.xml中的<dependencies>和</dependencies>元素之间加入依赖项。</p>
<p>如果依赖没有版本号，则Spring Boot会根据自己的版本号自动给依赖加上版本号；如果想指定版本，则在version元素上添加上版本信息。</p>
<h3 id="使用配置文件"><a href="#使用配置文件" class="headerlink" title="使用配置文件"></a>使用配置文件</h3><p>Spring Cloud(Spring Boot)支持Properties和Yml两种配置方式。</p>
<p>properties的优先级要高于yml。</p>
<p>yml的好处是——它采用的事树状结构，一目了然。</p>
<p>使用yml的方式要注意以下几点：</p>
<ul>
<li>原来按”.”分割的key会变成树状结构。</li>
<li>在key后的冒号后一定要跟一个空格。</li>
<li>如果把原有的application.properties删掉，则建议执行一下“maven -X clean install”命令</li>
<li>yml格式不支持用注解@PropertySource导入配置</li>
</ul>
<h4 id="配置文件application-properties"><a href="#配置文件application-properties" class="headerlink" title="配置文件application.properties"></a>配置文件application.properties</h4><ol>
<li><p>基础知识</p>
<p>配置框架，以及自定义应用程序的配置属性，是一个文本文件。每行结构是：属性键=属性值</p>
</li>
<li><p>读取属性值</p>
<p>支持两种方式读取配置项。</p>
<ul>
<li>SpEL表达式方式：@Value(“#{configProperties[‘key’]}”)</li>
<li>占位符方式：@Value(“${key}”)</li>
</ul>
</li>
<li><p>设置默认属性值</p>
<p>默认情况下，缺少配置项会导致异常。当缺少属性值时，可以在属性键后添加冒号(:)和默认值。</p>
</li>
<li><p>自定义属性值</p>
<ul>
<li><p>基本属性类型：字符串、整数、布尔值</p>
</li>
<li><p>多行字符串：如果很长，则可以将其用反斜杠“\”字符断开，分成几行以提高可读性。</p>
</li>
<li><p>数组、列表或集合：集合值需要用逗号（,）隔开，在调用时，只需将属性注入数组变量即可。例如：@Value(“${app.config.numbers}”) int[] numbers，List<Integer>numbers</p>
</li>
<li><p>列表属性的自定义分隔符</p>
<p>默认情况下，Spring使用逗号分隔属性值。如果要使用分号这样的分隔符，则可以如下使用：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">app.numbers</span>=<span class="hljs-string">0;1;2;3</span><br></code></pre></td></tr></table></figure>

<p>调用时使用分隔符即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Value</span>(<span class="hljs-string">"#&#123;'$&#123;app.numbers&#125;'&#125;.split(';')"</span>)<br>List&lt;Integer&gt; numbers;<br></code></pre></td></tr></table></figure>
</li>
<li><p>属性为Hashmap</p>
<p>对于HashMap，可以在配置时设置格式，例如</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">app.number-map</span>=<span class="hljs-string">&#123;key1:1,key2:2,key3:3&#125;</span><br></code></pre></td></tr></table></figure>

<p>然后调用的时候使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Value</span>(<span class="hljs-string">"#&#123;$&#123;app.number-map&#125;&#125;"</span>)<br>Map&lt;String,Integer&gt; numberMap;<br></code></pre></td></tr></table></figure>
</li>
<li><p>使用环境变量</p>
<p>在此配置文件中，可以设置属性值为环境变量，例如：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">app.config.java-home</span>=<span class="hljs-string">Java path:$&#123;JAVA_HOME&#125;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>注释</p>
<p>如要进行注释，只需将#号放在一行的开头即可。</p>
</li>
</ul>
</li>
</ol>
<h4 id="配置文件application-yml"><a href="#配置文件application-yml" class="headerlink" title="配置文件application.yml"></a>配置文件application.yml</h4><ul>
<li><p>简介</p>
<p>yaml语言是一种通用的数据串行化格式，它的基本语法规则如下：</p>
<ul>
<li>大小写敏感</li>
<li>使用缩进表示层级关系</li>
<li>在缩进时不允许使用Tab键，只允许使用空格</li>
<li>缩进的空格数目不重要，只要相同层级的元素左侧对其即可</li>
<li>‘#’ 表示注释，从这个字符一致到行尾都会被解析器忽略。</li>
</ul>
</li>
<li><p>yaml支持的数据类型</p>
<ul>
<li><p>对象：键值对的集合，又被成为映射(Mapping)、哈希、字典。对象的一组键值对用冒号结构表示。</p>
</li>
<li><p>数组：一组按次序排列的值，又被称为序列(Sequence)、列表(List)。</p>
<p>一组连词线开头的行构成一个数组。例如：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><code class="hljs yml"><span class="hljs-string">-A</span><br><span class="hljs-string">-B</span><br><span class="hljs-string">-C</span><br><span class="hljs-comment">#上面代码转换为['A','B','C']。</span><br><br><span class="hljs-bullet">-</span><br>	<span class="hljs-string">-A</span><br>	<span class="hljs-string">-B</span><br>	<span class="hljs-string">-C</span><br><span class="hljs-comment">#上面代码转换为[['A','B','C']]。</span><br></code></pre></td></tr></table></figure>

<p>数组也可以采用行内表示法，例如：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">car:[bmw,auid]</span><br><span class="hljs-comment">#上面代码转换为&#123;car:['bmw','audi']&#125;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>复合结构</p>
<p>对象和数组可以结合使用，形成复合机构</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">animal:</span><br>	<span class="hljs-string">-Cat</span><br>	<span class="hljs-string">-Pig</span><br><span class="hljs-attr">car:</span><br>	<span class="hljs-attr">BMW:</span> <span class="hljs-string">520LI</span><br>	<span class="hljs-attr">AUDI:</span> <span class="hljs-string">A7</span><br><span class="hljs-comment">#转换后：&#123;animal:['Cat','Pig'],cat:&#123;BMW:'520LI',AUDI:'A7'&#125;&#125;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>纯量</p>
<p>纯量是最基本的、不可再分的值</p>
<p>支持字符串、布尔值、整数、浮点数、NULL、时间、日期等具体值。</p>
</li>
</ul>
</li>
</ul>
<h3 id="应用程序分层开发模式-MVC"><a href="#应用程序分层开发模式-MVC" class="headerlink" title="应用程序分层开发模式-MVC"></a>应用程序分层开发模式-MVC</h3><h4 id="了解MVC模式"><a href="#了解MVC模式" class="headerlink" title="了解MVC模式"></a>了解MVC模式</h4><p>Spring Boot开发的Web应用程序主要使用MVC模式。</p>
<p>MVC模式是Mode(模型)、View(视图)、Controller(控制器)的简写</p>
<ul>
<li>Model：Java的实体Bean,代表存取数据的对象或POJO</li>
<li>View：主要用来解析、处理和显示内容，并进行模板的渲染</li>
<li>Controller：主要用来处理视图中的相应。它决定如何调用Mode的实体Bean，如何调用业务层的数据增删改查等业务操作，以及如何将结果返给视图进行渲染。</li>
</ul>
<p>在整个SpringMVC框架中，DispatcherServlet处于核心位置，继承自HttpServlet。它负责协调和组织不同组件，以完成请求处理并返回响应工作。</p>
<h4 id="MVC和三层架构的关系"><a href="#MVC和三层架构的关系" class="headerlink" title="MVC和三层架构的关系"></a>MVC和三层架构的关系</h4><p>三层架构就是将整个应用程序划分为：表现层、业务逻辑层、数据访问层。</p>
<ul>
<li>表现层：用于展示节目，接受用户的请求并返回数据</li>
<li>业务逻辑层：三层架构的服务层，负责业务逻辑处理，主要是调用DAO层对数据进行增删改查。</li>
<li>数据访问层：与数据库进行交互的持久层，被Service调用。</li>
</ul>
<p>Repository和Dao层都可以进行数据增删改查。它们相当于仓库管理员，执行进、出货操作</p>
<p><strong>Repository = 管理对象(对象缓存和在Repository的状态) + DAO</strong></p>
<p>三层架构是基于业务逻辑或功能来划分的，而MVC是基于页面或功能来划分的。</p>
<h3 id="响应式编程—WebFlux"><a href="#响应式编程—WebFlux" class="headerlink" title="响应式编程—WebFlux"></a>响应式编程—WebFlux</h3><h4 id="什么是WebFlux"><a href="#什么是WebFlux" class="headerlink" title="什么是WebFlux"></a>什么是WebFlux</h4><p>WebFlux是从Spring Framework5.0开始引入的反应式Web框架。与Spring MVC不同，它不需要Servlet API,完全异步且无阻塞，并通过Reactor实现Reactive Streams规范。</p>
<p>WebFlux可以在资源有限的情况下提高系统的吞吐量和伸缩性</p>
<p>WebFlux除了支持RESTful Web服务外，还可以用于提供动态HTML内容。</p>
<h4 id="比较MVC和WebFlux"><a href="#比较MVC和WebFlux" class="headerlink" title="比较MVC和WebFlux"></a>比较MVC和WebFlux</h4><ol>
<li><p>工作方式</p>
<p>MVC的工作方式是：主线程接收到Request请求-&gt;准备数据-&gt;返回数据。</p>
<p>WebFlux的工作流程：主线程接收到Request-&gt;立刻返回数据与函数的组合-&gt;开启一个新Work线程去做实际的准备数据工作，进行真正的业务操作-&gt;Work线程完成工作-&gt;返给用户真实数据(结果)</p>
</li>
<li><p>Spring MVC与Spring WebFlux区别</p>
<table>
<thead>
<tr>
<th>对比项</th>
<th>Spring MVC</th>
<th>Spring WebFlux</th>
</tr>
</thead>
<tbody><tr>
<td>路由映射</td>
<td>@Controller、@RequestMapping等标准注解</td>
<td>支持使用Router Functions的函数式风格Api来创建Router、Handler、Filter，还支持标准注解</td>
</tr>
<tr>
<td>数据流</td>
<td>Servlet API</td>
<td>Reactive Streams:一种支持背压的异步数据流处理标准</td>
</tr>
<tr>
<td>容器</td>
<td>Tomcat、Jetty、Undertow</td>
<td>Netty、Tomcat、Jetty、Undertow</td>
</tr>
<tr>
<td>I/O模型</td>
<td>同步阻塞</td>
<td>异步非阻塞</td>
</tr>
<tr>
<td>吞吐性能</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td>业务处理性能</td>
<td>一样</td>
<td>一样</td>
</tr>
<tr>
<td>支持数据库</td>
<td>NoSql、Sql</td>
<td>支持NoSQL，<u><strong>不支持MySQL等关系型数据库</strong></u>？</td>
</tr>
<tr>
<td>请求和响应</td>
<td>HttpServletRequest和HttpServletResponse</td>
<td>ServletRequest和ServletResponse</td>
</tr>
</tbody></table>
</li>
<li><p>使用WebFlux的好处</p>
<p>简单原理：你来了，我立马答应你，但是服务需要等待；而不是你来了没人理你，咨询服务半天也没人回复。</p>
<p>结论：MVC能满足的场景，就不需要改用WebFlux。WebFlux和MVC可以混合使用。</p>
</li>
</ol>
<h4 id="比较Mono与Flux"><a href="#比较Mono与Flux" class="headerlink" title="比较Mono与Flux"></a>比较Mono与Flux</h4><ol>
<li><p>Mono和Flux是什么</p>
<p>是Reactor中的两个基本概念。</p>
<ul>
<li>Mono和Flux都是事件发布者，为消费者提供订阅接口。</li>
<li>Mono和Flux用于处理异步数据流，将异步数据流包装成Mono或Flux对象</li>
</ul>
</li>
<li><p>Mono与Flux的区别</p>
<ol>
<li><p>Flux可以发送很多item，并且这些item在经过若干操作符后才被订阅</p>
</li>
<li><p>Mono用于返回单个数据。Flux用于返回多个数据</p>
</li>
<li><p>Mono表示包含0或1个元素的异步序列。在该序列中可以包含3中不同类型的消息通知</p>
<table>
<thead>
<tr>
<th>消息通知(事件发布者)</th>
<th>方法(事件订阅者)</th>
</tr>
</thead>
<tbody><tr>
<td>包含元素的消息</td>
<td>onNext()</td>
</tr>
<tr>
<td>序列结束的消息</td>
<td>onComplete()</td>
</tr>
<tr>
<td>序列出错的消息</td>
<td>onError()</td>
</tr>
</tbody></table>
</li>
<li><p>Flux和Mono可以进行转换。对一个Flux序列进行计数操作，得到的结果是一个Mono<Long>对象。</p>
</li>
</ol>
</li>
</ol>
<h4 id="开发WebFlux的流程"><a href="#开发WebFlux的流程" class="headerlink" title="开发WebFlux的流程"></a>开发WebFlux的流程</h4><ol>
<li><p>注解式开发流程</p>
<p>与MVC开发模式一样，地址映射通过注解@RequestMapping提供的，应注解@Controller代替Handler类</p>
</li>
<li><p>响应式开发流程</p>
<ol>
<li><p>创建Handler类</p>
<p>相当于SpringMVC中Controller层中的方法体。</p>
</li>
<li><p>配置RouterFunction</p>
<p>和@RequestMapping相似，都用于提供URL路径。</p>
</li>
</ol>
</li>
</ol>
<h3 id="了解Spring-Cloud-Commons"><a href="#了解Spring-Cloud-Commons" class="headerlink" title="了解Spring Cloud Commons"></a>了解Spring Cloud Commons</h3><p>如果在项目中依赖了“Spring-cloud-starter”，则会自动配置。</p>
<ul>
<li>Spring Cloud Commons：Spring Cloud Commons的通用抽象。</li>
<li>Spring Cloud Context：Spring Cloud的上下文。</li>
<li>Spring Cloud Commons：Commons下的Commons类，Spring Cloud的公共抽象类。</li>
</ul>
<h4 id="Spring-Cloud的上下文"><a href="#Spring-Cloud的上下文" class="headerlink" title="Spring Cloud的上下文"></a>Spring Cloud的上下文</h4><p>Spring Cloud Context为Spring Cloud应用程序的ApplicationContext提供公共和特殊的服务。</p>
<h4 id="Spring-Cloud的公共抽象类"><a href="#Spring-Cloud的公共抽象类" class="headerlink" title="Spring Cloud的公共抽象类"></a>Spring Cloud的公共抽象类</h4><p>Spring Cloud Commons是一组抽象和公共类，提供了服务注册与发现、负载均衡等抽象接口。</p>
<ol>
<li><p>DiscoveryClient接口</p>
<p>提供了一个简单的API接口用来发现客户端，Spring Cloud会自动去寻找DiscoveryClient接口的实现用作服务发现。</p>
<p>默认情况下，DiscoveryClient的实现类到自动注册本地的Spring Cloud服务器。</p>
<p>如果想禁用自动注册功能，则可以在@EnableDiscoveryClient中将autoRegister属性的值设置为false</p>
</li>
<li><p>ServiceRegistry接口</p>
<p>该接口提供了注册与撤销注册的方法。这里的Registration是一个标识接口，用来描述一个服务实例，其中包含实例的相关信息。</p>
</li>
<li><p>整合RestTemplate和Ribbon实现负载均衡</p>
<p>通常，在Spring Cloud项目中用Ribbon实现客户端负载均衡，是通过给RestTemplate添加注解@LoadBalaced实现的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//定义Riboon的RestTemplate</span><br><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@LoadBalanced</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title">restTemplate</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RestTemplate();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>然后使用以下代码来调用服务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">restTemplate.getForEntity(<span class="hljs-string">"http://provider/hello"</span>,String<span class="hljs-class">.<span class="hljs-keyword">class</span>).<span class="hljs-title">getBody</span>()</span><br></code></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>实战派</tag>
      </tags>
  </entry>
  <entry>
    <title>实战派(第4章)</title>
    <url>/2020/06/30/%E5%AE%9E%E6%88%98%E6%B4%BE-4/</url>
    <content><![CDATA[<h1 id="第4章-认识微服务"><a href="#第4章-认识微服务" class="headerlink" title="第4章 认识微服务"></a>第4章 认识微服务</h1><h4 id="微服务的优点："><a href="#微服务的优点：" class="headerlink" title="微服务的优点："></a>微服务的优点：</h4><ol>
<li>易于开发和维护：微服务架构由许多业务单一且服务自治的单个微服务组成，易于开发</li>
<li>启动速度更快：单个微服务业务单一，加载速度更快</li>
<li>局部修改后容易部署：修改单个后，只需将修改的微服务重新发布、部署即可</li>
<li>技术栈不受限：各模块微服务可用不同语言和工具开发</li>
<li>按需伸缩：根据不同需求，灵活增加相应服务的间的硬件资源等</li>
<li>松耦合(解耦)：由于业务单一和服务自治，内部是高内聚的，而微服务之间是松耦合的，因此每个微服务可以很容易按需扩展</li>
<li>弹性强(允许部分故障)：部分出现故障不会对整体的服务能力和可用性造成很大影响。</li>
</ol>
<p>除此之外，优点还有：测试和调试简化、水平扩展独立、复用性高、运维自动化、灵活性高等</p>
<h4 id="微服务的缺点："><a href="#微服务的缺点：" class="headerlink" title="微服务的缺点："></a>微服务的缺点：</h4><ol>
<li><p>运维要求较高：完整的微服务系统一般是由数十、数百、数千个独立的微服务实例构成。需要实现微服务的高可用集群部署，给开发和运维带来挑战。</p>
</li>
<li><p>分布式问题：</p>
<ol>
<li><p>分布式的复杂性：分布式本身的复杂性会导致微服务架构变得更加复杂，如系统的容错能力、网络延迟、分布式事务、依赖服务的不稳定等</p>
</li>
<li><p>分布式的事务问题：分布式的事务一致性问题在微服务系统中更为突出明显。</p>
<p>事务一致性方案有以下三种：</p>
<ul>
<li><p>可靠事件模式(Reliable Event Mode)：通过保证事件收发的高可靠性来保证事务的一致性。</p>
</li>
<li><p>补偿模式(Confirm Cancel)：如果最终确认失败，则全部逆序取消。</p>
</li>
<li><p>TCC模式(Try Confirm Cancel)：补偿模式的一种特殊实现，通常转账服务会采用这种模式。</p>
</li>
</ul>
</li>
<li><p>分布式的同步调用问题：</p>
<p>在微服务架构中，需要保证“在不确定的环境中交付确定的服务”,即在无法保证所依赖的服务的可靠性的情况下，要保证自己能够正常的提供服务。这个问题可以用SEDA（Staged Event Driven Architecture,分阶段的事件驱动架构）架构来解决</p>
<p>SEDA的核心思想是：将一个请求处理过程划分为多个Stage(阶段)，不同资源消耗的Stage使用不同数量的线程进行处理，哥哥Stage之间采用事件驱动的异步通信模式。</p>
</li>
</ol>
</li>
<li><p>接口调整成本高</p>
<ul>
<li><p>调用的修改</p>
</li>
<li><p>接口文档的编写</p>
</li>
<li><p>变更难以跟踪</p>
</li>
</ul>
</li>
<li><p>重复劳动：很多单个的微服务具有相同的功能，却没法将这些功能抽取出来供服务集群或其他微服务使用，因为微服务之间的调用是远程调用，常存在重复构建的情况。</p>
</li>
</ol>
<p>对于以上几个问题，可以通过技术、设计、开发原则和规范，以及管理来解决。例如：执行文档管理规定；实现统一的认证、配置、日志框架、综合分析监控平台；搭建持续集成平台等。</p>
<h4 id="微服务设计的原则"><a href="#微服务设计的原则" class="headerlink" title="微服务设计的原则"></a>微服务设计的原则</h4><ol>
<li><p>业务单一原则：只关注功能单一、有界限的业务员逻辑，从而完成某个特定的功能。</p>
</li>
<li><p>服务自治原则：每一个微服务都应具备独立的业务能力和运行环境，开发、测试、构建、部署等都可以独立运行， 包括数据库独立等。</p>
</li>
<li><p>轻量级通信原则：轻量级的通信应该具备以下两点：</p>
<ul>
<li><p>体量较轻：通信的语言非常轻量</p>
</li>
<li><p>能跨语言、跨平台：有足够的独立性，可以不受技术的限制。</p>
</li>
</ul>
</li>
<li><p>接口明确原则：接口之间尽可能具有通用性和灵活性。</p>
</li>
<li><p>弹性（容错性）设计原则：在依赖的服务宕机、网络连接出现问题时，应能够自动隔离服务、限制使用资源，即系统具有自我保护能力，可以使用比如Hystrix,可熔断、回滚等</p>
</li>
<li><p>自动化原则：</p>
<ol>
<li><p>自动化测试</p>
</li>
<li><p>自动化监控与管理日志</p>
<p>监控微服务的状态、快速定位异常或错误。</p>
<ul>
<li><p>监控功能主要包括监控服务的可用状态、请求流量、调用链、错误计数、服务依赖关系等内容，以便及时发现问题并解决问题。也可以根据监控状态来及时调整系统负载、过载保护等，从而保证系统的稳定性和高可用。</p>
</li>
<li><p>日志功能主要包括对微服务日志的收集、聚合、展现、搜索及报表等。比如ELK等</p>
</li>
</ul>
</li>
<li><p>持续集成和持续交付</p>
<ul>
<li><p>持续集成指频繁的将代码集成到主干、这样做可以迅速发现错误，防止分支过度偏离主干。</p>
</li>
<li><p>持续交付是指频繁费向测试人员和用户交付系统的新版本，以便进行测试和评审。</p>
</li>
</ul>
</li>
<li><p>持续部署</p>
</li>
</ol>
<p>持续部署是持续交付的下一个步骤，是指将通过的代码自动部署到生产环境中。比如Jenkins+Rancher等</p>
</li>
</ol>
<h4 id="领域驱动设计-DDD"><a href="#领域驱动设计-DDD" class="headerlink" title="领域驱动设计(DDD)"></a>领域驱动设计(DDD)</h4><p>领域驱动设计（Domain Driver Design,DDD）为微服务的划分提供了方法论，它能解决在微服务拆分中遇到的粒度问题。</p>
<p>需要从以下几个方面来理解领域驱动设计：</p>
<ol>
<li><p>问题域</p>
<p>要开发系统是因为遇到了问题，通过问题域可以知道需要做一个什么样的系统(即系统的目标)</p>
</li>
<li><p>领域</p>
<p>领域即边界。任何一个系统只能解决某一个边界内的问题，不可能解决漫无边际的问题。通过领域分析可以明确具体的需求。</p>
<p>问题域指导我们进行领域驱动设计，以解决领域中出现的问题。</p>
</li>
<li><p>设计</p>
<p>在确定了领域后，需要在领域中进行模型的设计。</p>
<p>DDD是一种基于模型驱动开发的软件开发思想，它可以帮助我们解决复杂的业务问题。</p>
</li>
<li><p>驱动</p>
<p>在DDD中，我们以领域为边界分析领域中的核心问题，根据核心问题设计对应的领域模型，再根据领域模型来驱动代码的实现。</p>
<p>DDD总体结构分为四层：Infrastructure（基础设施层）、Domain（领域层）、Application（应用层）、Interfaces（表示层，或”接口层”）。</p>
</li>
<li><p>限界上下文</p>
<p>限界上下文用来封装通用语言和领域对象，他为领域提供了上下文语境，保证领域内的术语、业务相关对象等具有一个确切的含义，不存在歧义。</p>
</li>
</ol>
<h4 id="跨服务的事务管理模式"><a href="#跨服务的事务管理模式" class="headerlink" title="跨服务的事务管理模式"></a>跨服务的事务管理模式</h4><p>一个逻辑工作单元要成为事务，必须满足ACID属性。</p>
<ul>
<li>A：原子性(Atomicity)，事务中的操作要么都不做，要么就全做。</li>
<li>C：一致性(Consistency)，在事务执行完后，数据库从一个一致性状态转换到另一个一致性状态。</li>
<li>I：隔离性(Isolation)，一个事务的执行不能被其他事务干扰。</li>
<li>D：持久性(Durability)，一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。</li>
</ul>
<p>在微服务中，进行事务管理主要有以下几种模式：</p>
<h5 id="2PC-3PC算法模式"><a href="#2PC-3PC算法模式" class="headerlink" title="2PC/3PC算法模式"></a>2PC/3PC算法模式</h5><blockquote>
<p>2PC/3PC是强一致，是资源层面的分布式事务，在两阶段提交的整个过程中一致会持有资源的锁。</p>
</blockquote>
<h5 id="TCC事务机制模式"><a href="#TCC事务机制模式" class="headerlink" title="TCC事务机制模式"></a>TCC事务机制模式</h5><p>TCC实现了Try、Confirm、Cancel三个操作的接口。</p>
<ul>
<li>Try：该接口检查所有的业务(一致性)，并预留业务资源(隔离性)。</li>
<li>Confirm：该接口不检查业务，只执行业务，使用的事Try阶段预留的业务资源。</li>
<li>Cancel：该接口取消执行业务，释放Try阶段预留的业务资源。</li>
</ul>
<blockquote>
<p>TCC是最终一致，是业务层面的分布式事务，不会一直持有资源的锁。</p>
</blockquote>
<h5 id="消息中间件模式"><a href="#消息中间件模式" class="headerlink" title="消息中间件模式"></a>消息中间件模式</h5><blockquote>
<p>引入消息中间件来进行异步处理、系统解耦、流量削事务管理等。</p>
<p>消息中间件是基于最终一致性来管理事务的。</p>
</blockquote>
<p>需要保证以下3要素：</p>
<ul>
<li><p>消息生产者一定要将数据消息投递到消息中间件服务器中（如RabbitMQ）。可以通过消息确认机制来保证成功投递。</p>
</li>
<li><p>消息消费者能够正确消费消息。可以采用手动ACK模式，这里需要注意重试幂等性问题。</p>
</li>
<li><p>保证第一个事务先执行。可以采用补偿机制。</p>
</li>
</ul>
<p>主流开元消息中间件有ActiveMQ、RabbitMQ、Kafka、Redis、RocketMQ。</p>
<h5 id="Saga模式"><a href="#Saga模式" class="headerlink" title="Saga模式"></a>Saga模式</h5><blockquote>
<p>Saga模式的核心思想史：将长事务拆分为多个可以交错运行的子事务集合，其中的每个子事务都保证事务的一致性。</p>
</blockquote>
<p>整个运行过程由Saga事务协调器来协调，如果每一个子事务都正常结束，则整个事务正常完成；如果某个子事务失败，则整个事务失败，会根据相反顺序执行<strong>补偿操作</strong>。</p>
<h5 id="Paxos算法模式"><a href="#Paxos算法模式" class="headerlink" title="Paxos算法模式"></a>Paxos算法模式</h5><blockquote>
<p>基于消息传递的一致性算法。这个算法被认为是类似算法中最有效的。Paxos算法解决在分布式系统中如何就某个值(决议)达成一致。</p>
</blockquote>
<h4 id="跨服务的查询模式"><a href="#跨服务的查询模式" class="headerlink" title="跨服务的查询模式"></a>跨服务的查询模式</h4><p>在微服务系统架构中，跨多个复位键的数据查询需求是很常见的，进行跨服务查询模式有两种：API组合器模式和CQRS模式。</p>
<ol>
<li>API组合器模式</li>
</ol>
<p>通过API组合器来调用多个服务，并将多个服务返回的结果组合在一起。</p>
<p>通常可以由服务消费者、网关和特别构建的服务来完成工作。</p>
<ol start="2">
<li>CQRS模式</li>
</ol>
<p>CQRS（Command Query Responsibility Segregation，命令查询职责分离）从业务上分离“读”和“写”行为，从而使得逻辑更加清晰，便于对不同部分进行针对性的优化。</p>
<p>这里的“读”指Query，不会对系统状态进行修改；这里的“写”指Command(增加、删除、修改)，会改变系统的状态。</p>
<h4 id="微服务部署"><a href="#微服务部署" class="headerlink" title="微服务部署"></a>微服务部署</h4><p>微服务的最初上线的部署模式主要有以下几种：</p>
<ul>
<li>按照编程语言发布特定的语言包格式部署。比如Java可以打包成WAR包或JAR包。</li>
<li>将服务部署在虚拟机</li>
<li>讲服务部署到容器。容器化技术Docker和Kubernetes极大地方方便了微服务的部署，可以说是时下最流行的微服务部署方式。</li>
<li>无服务部署Serverless。Serverless架构让人们不再操心运行所需的资源，只需关注自己的业务员逻辑，并且只为实际消耗的资源付费。</li>
</ul>
<h4 id="升级模式"><a href="#升级模式" class="headerlink" title="升级模式"></a>升级模式</h4><ol>
<li><p>蓝绿部署</p>
<p>不停机维护：集群分为蓝和绿两个部分，把全部流量切到绿色，升级蓝色集群；然后把全部流量切到蓝色集群，升级绿色集群，最后切换到全部集群中。</p>
</li>
<li><p>滚动部署</p>
<p>滚动部署是一种在更细的粒度下平滑升级版本的方式。一般取出一个或多个节点停止服务，然后执行更新，更新完成后再将这些停止的电接点重新投入使用，知道所有实例都被更新。</p>
</li>
<li><p>灰度发布（金丝雀发布）</p>
<p>很像滚动部署，但是在灰度期需要进行A/B测试。灰度发布可保证整个系统的稳定性，在灰度期间可以发现、调整问题。</p>
<p>A/B测试是指，一部分用户继续用产品特性A，另一部分用户开始用心的产品特性B，如果用户对产品特性B没有反对意见，则把所有用户都迁移到B上。</p>
<blockquote>
<p>如果数据库结构确实需要调整，则尽量通过增加数据库的字段来实现。</p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>实战派</tag>
      </tags>
  </entry>
  <entry>
    <title>实战派(第2-3章)</title>
    <url>/2020/06/15/%E5%AE%9E%E6%88%98%E6%B4%BE-2-3/</url>
    <content><![CDATA[<h1 id="第2章-准备开发环境和工具"><a href="#第2章-准备开发环境和工具" class="headerlink" title="第2章 准备开发环境和工具"></a>第2章 准备开发环境和工具</h1><p>在安装jdk中级的选择好安装位置，且路径中不要有中文，以便配置Jdk的环境变量。</p>
<h3 id="系统变量配置"><a href="#系统变量配置" class="headerlink" title="系统变量配置"></a>系统变量配置</h3><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">变量名</th>
<th align="left">变量值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Java</td>
<td align="center">JAVA_HOME</td>
<td align="left">JDK安装目录</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">CLASSPATH</td>
<td align="left">.%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar<br />【前面有个点不能丢失】</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">PATH</td>
<td align="left">%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin</td>
</tr>
<tr>
<td align="center">Maven</td>
<td align="center">MAVEN_HOME</td>
<td align="left">Maven解压目录</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">PATH</td>
<td align="left">%MAVEN_HOME%\bin</td>
</tr>
</tbody></table>
<p>POM（Project Object Model,项目对象模型）是Maven工程的基本工作单元，也是Maven的核心。</p>
<h3 id="POM中通常有以下元素"><a href="#POM中通常有以下元素" class="headerlink" title="POM中通常有以下元素"></a>POM中通常有以下元素</h3><ol>
<li><p>dependencies</p>
<p>在此元素下添加依赖，可以包含多个<dependency>依赖。</p>
</li>
<li><p>dependency</p>
<p><dependency>与</dependency>之间有以下3个标识</p>
<ul>
<li>groupId：定义率属的实际项目，坐标元素之一</li>
<li>artifactId：定义项目中的一个模块，坐标元素之一</li>
<li>version：定义依赖或项目的版本，坐标元素之一</li>
</ul>
</li>
<li><p>scope</p>
<p>如果编译时需要发布时不需要的JAR包，则可以用scope标签标示为provided。还可以设置为test、runtime等</p>
</li>
<li><p>properties</p>
<p>如果要使用自已顶的变量，则应在<properties></properties>元素中定义变量，然后在其他节点中引用该变量，比如统一版本号等</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span><br><span class="hljs-comment">&lt;!--使用时，可以通过表达式“$&#123;变量名&#125;”来调用。--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;java.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>plugin</p>
<p>在创建cloud和boot项目时，默认在POM文件中存在spring-boot-maven-plugin插件。它提供打包时所需的信息，将Spring Cloud应用打包为可执行的JAR或War文件</p>
</li>
</ol>
<h3 id="Maven配置国内仓库"><a href="#Maven配置国内仓库" class="headerlink" title="Maven配置国内仓库"></a>Maven配置国内仓库</h3><p>Maven安装目录下conf目录中，打开settings.xml文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">...<br><span class="hljs-tag">&lt;<span class="hljs-name">mirrors</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>alimaven<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>aliyun maven<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>central<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mirrors</span>&gt;</span><br>...<br></code></pre></td></tr></table></figure>

<h1 id="第3章-用Spring-Cloud实现一个微服务系统"><a href="#第3章-用Spring-Cloud实现一个微服务系统" class="headerlink" title="第3章 用Spring Cloud实现一个微服务系统"></a>第3章 用Spring Cloud实现一个微服务系统</h1><h3 id="用Eureka实现”服务中心”"><a href="#用Eureka实现”服务中心”" class="headerlink" title="用Eureka实现”服务中心”"></a>用Eureka实现”服务中心”</h3><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--Eureka服务器端需要的依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><em>上述依赖中，其实已经包含下述依赖，无需再引入：</em></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--spring cloud启动的依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>接下来需要配置“服务中心”的地址、端口号和应用名称，如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">#应用名称</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">Eureka</span> <span class="hljs-string">Server</span> <span class="hljs-string">Demo</span><br><span class="hljs-comment">#端口号</span><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-comment">#是否注册到Eureka Server,默认为true</span><br>    <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-comment">#是否从Eureka Server获取注册信息,默认为true</span><br>    <span class="hljs-attr">fetch-registry:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-comment">#设置Eureka Server交互的地址，查询服务和注册服务都需要依赖这个地址。多个地址可使用","分割</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-comment">#service-url下边是map对，注意defaultZone不是default-zone</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://localhost:$&#123;server.port&#125;/eureka/</span><br></code></pre></td></tr></table></figure>

<p>实现“服务中心”集群（满足高可用）：</p>
<p>eg.node1,node2,node3</p>
<p>node1的defaultZone配置为指向node2和node3：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>  <span class="hljs-comment">#设置Eureka Server交互的地址，查询服务和注册服务都需要依赖这个地址。多个地址可使用","分割</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://node2:8082/eureka/,http://node3:8083/eureka/</span><br></code></pre></td></tr></table></figure>

<p>通过配置项“eureka.client.serviceUrl.defaultZone”来配置多个”服务中心”。Eureka的默认地址是<a href="http://URL:8761/eureka。" target="_blank" rel="noopener">http://URL:8761/eureka。</a></p>
<p>分别启动三个节点，在节点node1的“DS Replicas”中已经有了node2,node3的配置信息，并且“available-replicas”中有node1、node2、node3的状态信息。如果停止node2,则会发现node2被移动到“unavailable-replicas”一栏中，标识node2不可用。</p>
<h3 id="用Eureka实现“服务提供者”"><a href="#用Eureka实现“服务提供者”" class="headerlink" title="用Eureka实现“服务提供者”"></a>用Eureka实现“服务提供者”</h3><p>创建项目时选择Eureka Discovery Client复选框</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--Eureka客户端的依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!--SpringBoot的web依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>这时候的配置可以连到所有的Eureka中,配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">#应用名称</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">provider</span><br><span class="hljs-comment">#端口号</span><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8000</span><br><span class="hljs-comment">#服务中心地址</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://node1:8081/eureka/,http://node1:8082/eureka/,http://node1:8083/eureka/</span><br></code></pre></td></tr></table></figure>

<p>启用注册和发现：</p>
<blockquote>
<p>要用Eureka启用客户端服务的注册和发现功能，可以使用注解@EnableEurekaClient和@EnableDiscoveryClient来实现。如果是使用其他“服务中心”（如Zookerper、Consul）,则只能使用注解@EnableDiscoveryClient来实现，@EnableEurekaClient是Eureka的专用注解。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-comment">//启用客户端的服务注册和发现功能</span><br><span class="hljs-meta">@EnableDiscoveryClient</span><br><span class="hljs-comment">//或者这个</span><br><span class="hljs-comment">//@EnableEurekaClient</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EurekaProviderApplication</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      SpringApplication.run(EurekaProviderApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>@Value</strong>注解用于获取配置中的信息</p>
<p>检查服务的有效性：进入Eureka注册中心的控制台，如果已经注册过，则在“Instances currently registered with Eureka”标题栏下方会出现“服务提供者”的应用名称。</p>
<p>“服务提供者”集群：以不同端口启动，连接到统一注册中心即可。</p>
<h3 id="用Fegin实现“服务消费者”"><a href="#用Fegin实现“服务消费者”" class="headerlink" title="用Fegin实现“服务消费者”"></a>用Fegin实现“服务消费者”</h3><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--Eureka客户端的依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!--SpringBoot的web依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!--Fegin客户端的依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>如果“服务消费者”不对外提供服务接口，则不需要将其注册到“服务中心”</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">#服务中心地址</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>  <span class="hljs-comment">#不注册到Eureka</span><br>    <span class="hljs-attr">fetch-registry:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://node1:8081/eureka/,http://node1:8082/eureka/,http://node1:8083/eureka/</span><br></code></pre></td></tr></table></figure>

<p>启用客户端的发现和远程调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-comment">//启用客户端的服务注册和发现功能</span><br><span class="hljs-meta">@EnableDiscoveryClient</span><br><span class="hljs-comment">//启用Feign的远程服务调用</span><br><span class="hljs-meta">@EnableFeignClients</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConsumerApplication</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      SpringApplication.run(ConsumerApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>调用“服务提供者”接口</p>
<blockquote>
<p>Feign是一个声明式Web Service客户端。使用Feign能让编写Web Service客户端更加简便。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//name:远程服务名，即"服务提供者"在"服务中心"中注册的名字</span><br><span class="hljs-meta">@FeignClient</span>(name = <span class="hljs-string">"provider"</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MyFeignClient</span> </span>&#123;<br>    <span class="hljs-meta">@RequestMapping</span>(value = <span class="hljs-string">"/hello"</span>)<br>    <span class="hljs-function">String <span class="hljs-title">hello</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>实现客户端接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConsumerController</span> </span>&#123;<br>    <span class="hljs-comment">//注入接口</span><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> MyFeignClient feignClient;<br>  <br>    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/hello"</span>)<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">index</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//返回内容</span><br>        <span class="hljs-keyword">return</span> feignClient.hello();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>测试微服务接口：</p>
<p>测试输出端口号，可关闭其中任意一个“服务提供者”或“服务中心”，再次访问，能够正常返回信息即为正常。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>实战派</tag>
      </tags>
  </entry>
  <entry>
    <title>第1周 万丈高楼，地基首要</title>
    <url>/2020/07/22/%E7%AC%AC1%E5%91%A8-%E4%B8%87%E4%B8%88%E9%AB%98%E6%A5%BC%E5%9C%B0%E5%9F%BA%E9%A6%96%E8%A6%81/</url>
    <content><![CDATA[<h4 id="演进历程"><a href="#演进历程" class="headerlink" title="演进历程"></a>演进历程</h4><h4 id="单节点"><a href="#单节点" class="headerlink" title="单节点"></a>单节点</h4><p>单纯静态页面 </p>
<p>mvc搭建的war包，文件存储，数据库全部存放至服务器</p>
<p>war包存放至服务器，文件存储在专门服务器，数据库专门服务器</p>
<p>随着查询量变大，增加缓存中间件，针对已查询的数据直接查缓存</p>
<h4 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h4><p>负载均衡 &lt;—&gt;应用集群(多个tomcat等)–文件服务器集群– 缓存服务器集群</p>
<h4 id="构建聚合工程"><a href="#构建聚合工程" class="headerlink" title="构建聚合工程"></a>构建聚合工程</h4><p>主pom文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.zzj<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>foodie-dev<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">modules</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>foodie-dev-common<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>foodie-dev-pojo<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>foodie-dev-mapper<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>foodie-dev-service<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>foodie-dev-api<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">modules</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--引入依赖 parent--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.5.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--设置资源属性--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.reporting.outputEncoding</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--&lt;exclusions&gt;</span><br><span class="hljs-comment">                &lt;exclusion&gt;</span><br><span class="hljs-comment">                    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="hljs-comment">                    &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;</span><br><span class="hljs-comment">                &lt;/exclusion&gt;</span><br><span class="hljs-comment">            &lt;/exclusions&gt;--&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--Web模块--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--引入xml、properties等自动配置--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- mysql驱动 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.41<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span> <span class="hljs-comment">&lt;!-- mybatis --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>foodie-dev-api中的yml文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8088</span><br>  <span class="hljs-attr">tomcat:</span><br>    <span class="hljs-attr">uri-encoding:</span> <span class="hljs-string">UTF-8</span><br>  <span class="hljs-attr">max-http-header-size:</span> <span class="hljs-string">80KB</span><br><br><span class="hljs-comment">## 数据层HikariCP与MyBatis整合   </span><br><span class="hljs-comment">## 配置数据源信息</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span> <span class="hljs-comment"># 数据源的相关配置</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">com.zaxxer.hikari.HikariDataSource</span> <span class="hljs-comment"># 数据源类型：HikariCP</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.jdbc.Driver</span> <span class="hljs-comment"># mysql驱动</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/foodie-shop-dev?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">hikari:</span><br>      <span class="hljs-attr">connection-timeout:</span> <span class="hljs-number">30000</span> <span class="hljs-comment"># 等待连接池分配连接的最大时长（毫秒），超过这个时长还没可用的连接则发生SQ</span><br>      <span class="hljs-attr">minimum-idle:</span> <span class="hljs-number">5</span> <span class="hljs-comment"># 最小连接数</span><br>      <span class="hljs-attr">maximum-pool-size:</span> <span class="hljs-number">20</span> <span class="hljs-comment"># 最大连接数</span><br>      <span class="hljs-attr">auto-commit:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 自动提交</span><br>      <span class="hljs-attr">idle-timeout:</span> <span class="hljs-number">600000</span> <span class="hljs-comment"># 连接超时的最大时长（毫秒），超时则被释放（retired），默认:10分钟</span><br>      <span class="hljs-attr">pool-name:</span> <span class="hljs-string">DateSourceHikariCP</span> <span class="hljs-comment"># 连接池名字</span><br>      <span class="hljs-attr">max-lifetime:</span> <span class="hljs-number">1800000</span> <span class="hljs-comment"># 连接的生命时长（毫秒），超时而且没被使用则被释放（retired），默认:30分钟</span><br>      <span class="hljs-attr">connection-test-query:</span> <span class="hljs-string">SELECT</span> <span class="hljs-number">1</span><br>      <br><span class="hljs-comment">## mybatis 配置</span><br><span class="hljs-attr">mybatis:</span><br>  <span class="hljs-attr">type-aliases-package:</span> <span class="hljs-string">com.zzj.pojo</span>   <span class="hljs-comment">#所有pojo类</span><br>  <span class="hljs-attr">mapper-locations:</span> <span class="hljs-string">classpath:mapper/*.xml</span>  <span class="hljs-comment">#mapper映射文件</span><br></code></pre></td></tr></table></figure>

<h4 id="PDMan数据库建模工具使用"><a href="#PDMan数据库建模工具使用" class="headerlink" title="PDMan数据库建模工具使用"></a>PDMan数据库建模工具使用</h4><p>官网：<a href="http://www.pdman.cn/#/" target="_blank" rel="noopener">http://www.pdman.cn/#/</a></p>
<p>PowerDesigner有以下几个不足之处</p>
<ol>
<li>商业化，收费，价格还很贵（<em>* *敲黑板，重点</em> **）。</li>
<li>功能太强大，隐藏较深，上手有一定难度，使用起来比较复杂。</li>
<li>仅限Windows平台使用。</li>
<li>复杂的功能，配置起来非常麻烦。</li>
<li>可以支持生成数据库的DDL建表语句以及JavaBean代码，但个性定制极其复杂。</li>
<li>自动生成文档格式非常难以调整。</li>
</ol>
<p>PDMan特点：</p>
<ol>
<li>永远免费使用（<em>* * 敲黑板，重点</em> **），目前已经使用MIT协议开源。</li>
<li>功能简洁，去除晦涩难懂的设置，化繁为简，实用为上，上手非常容易。</li>
<li>Windows，Mac，Linux三个平台均可以使用（<em>* *敲黑板，重点</em> **）。</li>
<li>自带参考案例，学习容易。新建一个项目，完全不需要做任何配置。</li>
<li>对开发极其友好，可生成各种数据库以及编程语言的模型类。</li>
<li>目前系统默认实现了MySQL,Oracle,Java的代码自动生成，并且带注释。其他类型的数据库或语言，只需要添加相应的“数据库”并设置好相应的doT模板就可以了。</li>
<li>一键自动生成MarkDown以及HTML格式的数据表结构文档，方便客户交付以及交流。</li>
<li>数据库模型版本管理功能，在版本变动之后，可直接生成数据表结构的DDL语句。</li>
<li>数据库模型设计直接同步至数据库。</li>
</ol>
<h4 id="Rest设计规范"><a href="#Rest设计规范" class="headerlink" title="Rest设计规范"></a>Rest设计规范</h4><ul>
<li>GET -&gt; /order/{id}                   -&gt;/getOrder?id=10001</li>
<li>POST -&gt;/order             另外传json             -&gt;/saveOrder</li>
<li>PUT -&gt;order/{id}                 -&gt;modifyOrder</li>
<li>DELETE -&gt;/order/{id}          -&gt;deleteOrder?id=10001</li>
</ul>
<h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><table>
<thead>
<tr>
<th><strong>事务传播行为类型</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>PROPAGATION_REQUIRED</td>
<td>如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择。</td>
</tr>
<tr>
<td>PROPAGATION_SUPPORTS</td>
<td>支持当前事务，如果当前没有事务，就以非事务方式执行。</td>
</tr>
<tr>
<td>PROPAGATION_MANDATORY</td>
<td>使用当前的事务，如果当前没有事务，就抛出异常。</td>
</tr>
<tr>
<td>PROPAGATION_REQUIRES_NEW</td>
<td>新建事务，如果当前存在事务，把当前事务挂起。</td>
</tr>
<tr>
<td>PROPAGATION_NOT_SUPPORTED</td>
<td>以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</td>
</tr>
<tr>
<td>PROPAGATION_NEVER</td>
<td>以非事务方式执行，如果当前存在事务，则抛出异常。</td>
</tr>
<tr>
<td>PROPAGATION_NESTED</td>
<td>如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。</td>
</tr>
</tbody></table>
<h4 id="Swagger2介绍"><a href="#Swagger2介绍" class="headerlink" title="Swagger2介绍"></a>Swagger2介绍</h4><p>使用 Swagger2 可以减少编写过多的文档，只需要通过代码就能生成文档API,提供给前端人员非常方便。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- swagger2 配置 --&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.4.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.4.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span> <br><span class="hljs-comment">&lt;!--swagger2 的UI，访问doc.html即可--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.xiaoymin<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>swagger-bootstrap-ui<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Swagger2配置类</span><br><span class="hljs-comment"> * 在与spring boot集成时，放在与Application.java同级的目录下。</span><br><span class="hljs-comment"> * 通过<span class="hljs-doctag">@Configuration</span>注解，让Spring来加载该类配置。</span><br><span class="hljs-comment"> * 再通过<span class="hljs-doctag">@EnableSwagger</span>2注解来启用Swagger2。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableSwagger</span>2<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Swagger2Config</span> </span>&#123;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建API应用</span><br><span class="hljs-comment">     * apiInfo() 增加API相关信息</span><br><span class="hljs-comment">     * 通过select()函数返回一个ApiSelectorBuilder实例,用来控制哪些接口暴露给Swagger来展现，</span><br><span class="hljs-comment">     * 本例采用指定扫描的包路径来定义指定要建立API的目录。</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">createRestApi</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2)<br>                .apiInfo(apiInfo())<br>                .select()<br>                .apis(RequestHandlerSelectors.basePackage(<span class="hljs-string">"com.zzj.controller"</span>))<br>                .paths(PathSelectors.any())<br>                .build();<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建该API的基本信息（这些基本信息会展现在文档页面中）</span><br><span class="hljs-comment">     * 访问地址：http://项目实际地址/swagger-ui.html</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> ApiInfo <span class="hljs-title">apiInfo</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ApiInfoBuilder()<br>                .title(<span class="hljs-string">"Spring Boot中使用Swagger2构建RESTful APIs"</span>)<br>                .description(<span class="hljs-string">"更多请关注http://www.baidu.com"</span>)<br>                .termsOfServiceUrl(<span class="hljs-string">"http://www.baidu.com"</span>)<br>                .contact(<span class="hljs-string">"sunf"</span>)<br>                .version(<span class="hljs-string">"1.0"</span>)<br>                .build();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//实现跨域注解</span><br><span class="hljs-comment">//origin="*"代表所有域名都可访问</span><br><span class="hljs-comment">//maxAge飞行前响应的缓存持续时间的最大年龄，简单来说就是Cookie的有效期 单位为秒</span><br><span class="hljs-comment">//若maxAge是负数,则代表为临时Cookie,不会被持久化,Cookie信息保存在浏览器内存中,浏览器关闭Cookie就消失</span><br><span class="hljs-meta">@CrossOrigin</span>(origins = <span class="hljs-string">"*"</span>,maxAge = <span class="hljs-number">3600</span>)<br></code></pre></td></tr></table></figure>

<h4 id="使用切面-AspectJ开发AOP"><a href="#使用切面-AspectJ开发AOP" class="headerlink" title="使用切面@AspectJ开发AOP"></a>使用切面@AspectJ开发AOP</h4><h5 id="1、切面-Aspect"><a href="#1、切面-Aspect" class="headerlink" title="1、切面(Aspect)"></a>1、切面(Aspect)</h5><p>　　一系列Advice + Pointcut 的集合。</p>
<h5 id="2、通知-Advice"><a href="#2、通知-Advice" class="headerlink" title="2、通知(Advice)"></a>2、通知(Advice)</h5><p>　　通知是切面开启后，切面的方法。</p>
<ul>
<li>前置通知 ( before )：在动态代理反射原有对象方法 或者 执行环绕通知 前 执行的通知功能</li>
<li>后置通知（after）：在动态代理反射原有对象方法 或者 执行环绕通知 后 执行的通知功能</li>
<li>返回通知 （afterReturning）：在动态代理反射原有对象方法 或者 执行环绕通知 后 正常返回（无异常）执行的通知功能</li>
<li>异常通知（afterTherowing）：在动态代理反射原有对象方法 或者 执行环绕通知 产生异常后执行的通知功能</li>
<li>环绕通知（around）：在动态代理中，它可以取代当前被拦截对象的方法，提供回调原有被拦截对象的方法</li>
</ul>
<h5 id="3、引入-Introduction"><a href="#3、引入-Introduction" class="headerlink" title="3、引入(Introduction)"></a>3、引入(Introduction)</h5><p>　　引入允许我们在现有的类里添加自定义的类和方法</p>
<h5 id="4、切点-Pointcut"><a href="#4、切点-Pointcut" class="headerlink" title="4、切点(Pointcut)"></a>4、切点(Pointcut)</h5><p>　　这是一个告诉Spring AOP 在什么时候启动拦截并织入对应的流程，因为并不是所有的开发都是需要启动AOP的，它往往通过正则表达进行限定</p>
<h5 id="5、连接点-join-point"><a href="#5、连接点-join-point" class="headerlink" title="5、连接点( join point)"></a>5、连接点( join point)</h5><p>　　Pointcut 中的某个具体位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Slf</span>4j<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServiceLogAspect</span> </span>&#123;<br><br>    <span class="hljs-meta">@Pointcut</span>(<span class="hljs-string">"execution(* com.zzj.service.impl..*.*(..))"</span>)<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">point</span><span class="hljs-params">()</span></span>&#123;&#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 环绕通知</span><br><span class="hljs-comment">     * 对实现方法进行检测，接口超过3秒的以error日志打印</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> joinPoint</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Around</span>(<span class="hljs-string">"point()"</span>)<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">recordTimeLog</span><span class="hljs-params">(ProceedingJoinPoint joinPoint)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br><br>        log.info(<span class="hljs-string">"--------开始执行:&#123;&#125;.&#123;&#125;-----------"</span>, joinPoint.getTarget().getClass().getSimpleName(),<br>                joinPoint.getSignature().getName());<br>        <span class="hljs-keyword">long</span> begin = System.currentTimeMillis();<br>        Object result = joinPoint.proceed();<br>        <span class="hljs-keyword">long</span> end = System.currentTimeMillis();<br>        <span class="hljs-keyword">long</span> takeTime = end - begin;<br>        <span class="hljs-keyword">if</span> (takeTime &gt; <span class="hljs-number">3000</span>) &#123;<br>            log.error(<span class="hljs-string">"--------执行结束，耗时：&#123;&#125;毫秒-----------------"</span>, takeTime);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (takeTime &gt; <span class="hljs-number">2000</span>) &#123;<br>            log.warn(<span class="hljs-string">"--------执行结束，耗时：&#123;&#125;毫秒-----------------"</span>, takeTime);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            log.info(<span class="hljs-string">"--------执行结束，耗时：&#123;&#125;毫秒-----------------"</span>, takeTime);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="SpringBoot-日志"><a href="#SpringBoot-日志" class="headerlink" title="SpringBoot 日志"></a>SpringBoot 日志</h4><p>1.移除默认日志</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span> <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>2.添加日志框架依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--引入日志依赖 抽象层 与 实现层--&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.21<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-log4j12<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.21<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>3.创建 log4j.properties 并且放到资源文件目录 src/main/resources </p>
<figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">log4j.rootLogger</span>=<span class="hljs-string">DEBUG,stdout,file </span><br><span class="hljs-meta">log4j.additivity.org.apache</span>=<span class="hljs-string">true </span><br><span class="hljs-meta">log4j.appender.stdout</span>=<span class="hljs-string">org.apache.log4j.ConsoleAppender </span><br><span class="hljs-meta">log4j.appender.stdout.threshold</span>=<span class="hljs-string">INFO </span><br><span class="hljs-meta">log4j.appender.stdout.layout</span>=<span class="hljs-string">org.apache.log4j.PatternLayout </span><br><span class="hljs-meta">log4j.appender.stdout.layout.ConversionPattern</span>=<span class="hljs-string">%-5p %c&#123;1&#125;:%L - %m%n </span><br><span class="hljs-meta">log4j.appender.file</span>=<span class="hljs-string">org.apache.log4j.DailyRollingFileAppender </span><br><span class="hljs-meta">log4j.appender.file.layout</span>=<span class="hljs-string">org.apache.log4j.PatternLayout </span><br><span class="hljs-meta">log4j.appender.file.DatePattern</span>=<span class="hljs-string">'.'yyyy-MM-dd-HH-mm </span><br><span class="hljs-meta">log4j.appender.file.layout.ConversionPattern</span>=<span class="hljs-string">%d&#123;yyyy-MM-dd HH:mm:ss&#125; %-5p %c&#123;1&#125;:%L - %m%n log4j.appender.file.Threshold=INFO </span><br><span class="hljs-meta">log4j.appender.file.append</span>=<span class="hljs-string">true </span><br><span class="hljs-meta">log4j.appender.file.File</span>=<span class="hljs-string">/workspaces/logs/foodie-api/mylog.log</span><br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
</search>
